---
title: "First Boot — Scaffolding an Astro v6 Project"
description: "Turning the Astro and Cloudflare decisions into a running project — from bun create astro to first deploy, and knowing when to stop."
date: 2026-02-14
draft: true
tags: ["Building in Public", "Astro", "Cloudflare"]
---

*This is Part 1 of [Building in Public](/tags/building-in-public), a series documenting the construction of this site.*

The [previous post](/posts/why-astro-cloudflare) covered the reasoning behind choosing Astro and Cloudflare Workers. This one covers what happened next: turning those decisions into a running project.

The goal was narrow on purpose. Get a dev server running, get the deployment target wired up, and stop. No design, no content system, no styling — just confirm that the toolchain works end to end before building on top of it.

## The scaffolding command

Astro has a CLI scaffolding tool, and I used Bun as my package manager from the start:

```bash
bun create astro
```

The interactive wizard walks you through a few choices. I went with:

- **Empty project** — no starter template. I wanted to understand every file in the repo, not inherit someone else's opinions.
- **TypeScript, strict mode** — strict TypeScript is arguably overkill for a personal blog, but it's the kind of overkill I like to do on small projects to reinforce habits I use for big ones. It catches real bugs in component props and content schemas, and it makes AI assistants noticeably more useful — they generate better code when they have types to work with.
- **No sample files** — just `astro.config.mjs`, `tsconfig.json`, `package.json`, and a single `src/pages/index.astro`.

The result is a project with about five files — running Astro v5 (stable). Since I'd already decided to bet on v6, the next step was upgrading.

I expected this to be straightforward. It wasn't, quite. Neither `bun create astro@latest` nor `npx create astro -- --ref next` installed the v6 beta — both gave me stable v5. The scaffolder doesn't have a beta channel. The solution was simple enough: scaffold with stable, then upgrade:

```bash
bun add astro@beta
```

This pulls in the latest v6 beta and updates `package.json` accordingly. The [Astro v6 upgrade guide](https://v6.docs.astro.build/en/guides/upgrade-to/v6/) covers what's changed. From here on out, everything I build is on the version Cloudflare will be optimizing for.

A small lesson here: if you're adopting a beta, the scaffolding tools may not support it yet. Plan for a two-step process — scaffold stable, then upgrade. It's a minor papercut, but the kind of thing that costs you thirty minutes of confusion if you don't expect it.

## Adding the Cloudflare adapter

The deployment decision from the previous post needed to connect to real config. That meant adding the Cloudflare adapter early, before building anything else:

```bash
bun add @astrojs/cloudflare@beta
```

Since we're on Astro v6 beta, we need the matching v13 beta of the adapter — the stable release targets Astro v5. The [Cloudflare adapter docs](https://v6.docs.astro.build/en/guides/integrations-guide/cloudflare/) cover the full configuration reference.

And in `astro.config.mjs`:

```js
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  output: 'static',
  adapter: cloudflare(),
});
```

Two things worth noting here. First, `output: 'static'` — Astro defaults to static rendering, and that's what I want. The adapter handles deploying the static output to Cloudflare Workers. Second, I'm adding the adapter before I have anything to deploy. This is deliberate. At work, I've seen too many projects build for weeks against a local dev server and then scramble to sort out deployment. Wiring up the target environment early — even when there's nothing meaningful to deploy — surfaces integration issues when they're cheap to fix.

The Wrangler config is similarly minimal — a `wrangler.jsonc` that names the project, points at the build output, and enables Node.js compatibility:

```jsonc
{
  "name": "gtw-astro",
  "main": "@astrojs/cloudflare/entrypoints/server",
  "compatibility_flags": ["nodejs_compat"],
  "assets": { "directory": "./dist" }
}
```

That's the entire deployment configuration.

## First boot

```bash
bun run dev
```

Astro's dev server starts, Vite spins up, and there's a page at `localhost:4321` with whatever I put in `index.astro`. At this point that's a single `<h1>` tag. Not much to look at, but it confirms the toolchain works: Bun resolves dependencies, Vite serves the project, Astro renders the page, and TypeScript is checking types.

I've learned not to take this step for granted. A working dev server means the foundation is solid. Everything after this is building on something real; everything before it is speculation.

## First build

Before deploying anywhere, I wanted to verify the production build locally:

```bash
bun run build && bun run preview
```

`astro build` generates the static output into `dist/`, and `astro preview` serves it locally. This is the same habit I'd recommend on any project — catching build-only issues locally is always cheaper than discovering them in production.

## First deploy

With the build verified, I added a deploy script to `package.json`:

```json
"scripts": {
  "dev": "astro dev",
  "build": "astro build",
  "preview": "astro preview",
  "deploy": "astro build && wrangler deploy"
}
```

Then the first deploy was a single command:

```bash
bun run deploy
```

Wrangler comes along with the Cloudflare adapter, so there's nothing else to install. Astro builds the static output and Wrangler pushes the result to Cloudflare Workers. The site goes live at a `.workers.dev` subdomain — not a real domain yet, but proof that the full pipeline works from source to production. No GitHub integration needed — this is just a manual push from my machine to Cloudflare's edge.

I'm skipping over the Cloudflare account setup and Wrangler authentication here — it's straightforward and [well-documented](https://developers.cloudflare.com/workers/get-started/guide/).

The takeaway from this step is how little is required. Five config files, three commands (scaffold, build, deploy), and the site is live at the edge. The beta adds some version-matching friction — making sure Astro and the Cloudflare adapter are on compatible beta tracks — but the core workflow is clean.

## Connecting GitHub

With the manual deploy working, I connected the GitHub repo to Cloudflare's deployment integration. Commits to `main` now trigger automatic deploys. This isn't CI/CD in any serious sense — there are no tests, no linting, no checks beyond what `astro build` does. A broken commit goes live immediately. But the friction is low enough that I'd rather keep moving and add guardrails when there's something worth guarding.

Whether this holds up as the project grows is an open question. At some point I'll want quality gates — type checking, maybe accessibility checks, maybe Lighthouse scores. For now, the auto-deploy gives me fast feedback loops, and that matters more at this stage than safety nets.

## What the project looks like at this point

After scaffolding, the project is sparse:

```
├── astro.config.mjs
├── package.json
├── tsconfig.json
├── wrangler.jsonc
└── src/
    └── pages/
        └── index.astro
```

No components, no layouts, no styles, no content directory. Just config and a single page. I want to add each layer intentionally, understanding what it does and why it's there. That's a luxury of a personal project — at work, scaffolding decisions often get made quickly and lived with for years. Here, I can be deliberate.

## What we're deferring

Almost everything. At this point the project runs and deploys, and that's all it does. Explicitly not yet:

- **Domain configuration** — the site lives at a `.workers.dev` URL
- **Any design or styling** — not even a CSS file
- **Content system** — no collections, no schema, no blog posts
- **CI/CD** — auto-deploy on push, but no quality gates
- **Analytics, dark mode, search** — not even on the horizon yet

The [next post](/posts/setting-up-the-workshop) covers what I did before writing any components or content: setting up the project documentation that shapes every AI-assisted session that follows.
